import { GetServerSidePropsContext, InferGetServerSidePropsType } from "next";
import { useSession } from "next-auth/react";
import Head from "next/head";
import { useRouter } from "next/router";
import { useEffect } from "react";

import { SelectedProvider, useSelected } from "@/components/context/SelectedProvider";
import { Dashboard } from "@/components/layouts/Dashboard";
import Access from "@/utils/access";
import { fetchServer, fetchSettings } from "@/utils/fetchSSRProps";
import { IPermissionConstants, PERMISSIONS } from "@/utils/permission";
import { Flex } from "@mantine/core";
import { ISetting } from "@pm2.web/typings";

import ProcessItem from "@/components/process/ProcessItem";

function Process({ settings }: { settings: ISetting }) {
  const { servers, selectItem, selectedItem } = useSelected();
  const { data: session } = useSession();
  const router = useRouter();

  const hasPermission = (process_id: string, server_id: string, permission?: keyof IPermissionConstants) => {
    const user = session?.user;
    if (!user || !user.acl) return false;
    if (!user?.acl?.owner && !user?.acl?.admin) {
      if (permission)
        return new Access(user.acl?.servers ?? []).getPerms(server_id, process_id).has(PERMISSIONS[permission]);
      return !!new Access(user.acl?.servers ?? []).getPermsValue(server_id, process_id);
    }
    return true;
  };

  const selectedProcesses = servers
    ?.map((server) =>
      server.processes.filter(
        (process) => selectedItem?.servers?.includes(server._id) || selectedItem?.servers?.length === 0,
      ),
    )
    .flat()
    .filter(
      (process) =>
        (selectedItem?.processes?.includes(process._id) || (selectedItem?.processes?.length || 0) === 0) &&
        hasPermission(process._id, process.server),
    );

  useEffect(() => {
    //refresh ssr props
    const interval = setInterval(
      async () => {
        router.replace(router.asPath);
      },
      Math.min(settings.polling.frontend * 2, 10_000),
    );
    return () => clearInterval(interval);
  }, []);

  return (
    <Flex gap="xs" direction={"column"}>
      {selectedProcesses?.map((process) => <ProcessItem process={process} key={process._id} setting={settings} />)}
    </Flex>
  );
}

export default function ProcessPage({ servers, settings }: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return (
    <>
      <Head>
        <title>pm2.web</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" type="image/png" href="/logo.png" />
      </Head>
      <SelectedProvider servers={servers}>
        <Dashboard>
          <Process settings={settings} />
        </Dashboard>
      </SelectedProvider>
    </>
  );
}

export async function getServerSideProps({ req, res }: GetServerSidePropsContext) {
  res.setHeader("Cache-Control", "s-maxage=10, stale-while-revalidate");

  const settings = await fetchSettings();
  return {
    props: {
      servers: await fetchServer(settings.excludeDaemon),
      settings,
    },
  };
}
